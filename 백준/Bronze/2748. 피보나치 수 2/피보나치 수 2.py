import sys
input = sys.stdin.readline

def fibo(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        a = 0 # n = 0
        b = 1 # n = 1
        for _ in range(2, n + 1): # n이 2부터 피보나치 점화식이 적용됨
            # 메모이제이션(Memoization, 메모리가 아님) 기억한다가 아니라 메모한다 라는 뜻
            temp = a # swap
            a = b
            b = temp + b
        return b # 시간복잡도 = O(N)

n = int(input())
print(fibo(n))

# 점화식 = n번째 항에 대한 정보를 얻기 위해 이전 항에 대한 정보가 필요한 경우(n에 대한 일반식이 아님)
# 그리고 이러한 점화식이 등차수열의 n번째 항에 대한 점화식처럼 n에 값이 정해지면 바로 구해지는 것이 아니라
# 이전 값들이 계속해서 꼬리를 물면서 비효율적인 중복호출을 발생시키는지 여부를 판단해야함
# 비효율적인 중복호출이 꼬리를 물고 계속해서 발생한다면 그때 DP를 써야함
# DP를 쓰기로 결정한 후 어떤 접근법을 선택할 것인지에 대한 판단 기준은 다음과 같다

# 중복 계산이 생겨서 DP가 필요하다고 판단된 뒤에는, 
# 구현 스타일에 따라 Top-Down(메모이제이션)과 Bottom-Up(타뷸레이션)을 고릅니다. 
# 선택 기준은 주로 다음 세 가지를 봅니다.

# 1. 재귀 깊이와 순회 순서
# 상태 전이가 재귀적으로 자연스럽게 떠오르고, 호출 깊이가 크지 않으면 Top-Down이 편합니다. 
# 반대로 명확한 “쌓이는 순서”를 잡을 수 있고 재귀가 너무 깊어질 우려가 있으면 Bottom-Up이 안전합니다.

# 2. 필요한 상태만 계산할지 여부
# 어떤 상태가 실제로 사용될지 확신이 없고, 조건에 따라 일부만 방문한다면 
# Top-Down이 필요할 때만 계산하니 낭비가 적습니다. 
# 모든 상태가 반드시 필요하고 순차적으로 계산해도 된다면 Bottom-Up이 더 단순합니다.
    # -> 해설: 이미 우리가 계산해야 하는 상태 범위(예: n ≤ 1000 등)가 정해져 있다면 
    # 그 범위만큼 테이블을 쭉 채워 가도 낭비가 없다는 뜻입니다. 
    # 즉, 입력마다 n이 달라도 최댓값이 제한돼 있으면 미리 그 범위까지 bottom-up으로 채워 두었다가 
    # dp[n]을 꺼내 쓰면 됩니다. 

# 3. 메모리·초기화 관리
# Bottom-Up은 테이블 전체를 미리 만들어 채워야 하므로 초기값과 순서를 정확히 다뤄야 하지만, 
# 반복문 한 번이면 끝이라 호출 스택 부담이 없습니다. 
# Top-Down은 캐시 구조만 마련하면 설계가 직관적이지만, 재귀 오버헤드와 스택 제한을 신경 써야 합니다.

# 스택제한을 신경써야 하는 이유는
# macOS: 기본 가용 스택이 8 MB 정도
# Windows: 기본 프로세스 메인 스레드 스택은 컴파일러 설정에 따라 달라지지만, 기본적으로 1 MB

# 스택 메모리 제한은 OS/런타임이 정한 “스택 전체 크기” 한도입니다. 호출 스택과 지역 변수, 함수 호출 프레임이 모두 여기에 잡히죠.
# recursion limit은 언어 구현이 추가로 두는 “재귀 호출 횟수” 제한입니다. 
# 파이썬의 sys.getrecursionlimit()처럼 스택이 차기 전에 미리 차단해 스택 오버플로를 방지하는 보호 장치예요.
# 즉, recursion limit은 스택이 터지기 전에 걸어둔 소프트 제한이고, 
# 이걸 풀어도 결국 OS가 허용한 스택 크기를 넘으면 RecursionError 대신 스택 오버플로(세그폴트 등)가 납니다. 
# 그래서 둘은 별개지만 실질적으로는 recursion limit ≤ 스택 한도 관계로 함께 움직인다고 보면 됩니다.